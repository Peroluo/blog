# 时间和空间复杂度

![](../img/space.png)


算法（Algorithm）是指用来操作数据、解决程序问题的一组方法。对于同一个问题，使用不同的算法，也许最终得到的结果是一样的，但在过程中消耗的资源和时间却会有很大的区别。

那么我们应该如何去 **衡量不同算法之间的优劣** 呢？

主要还是从算法所占用的「时间」和「空间」两个维度去考量。

- **时间维度**：是指执行当前算法所消耗的时间，我们通常用「时间复杂度」来描述。
- **空间维度**：是指执行当前算法需要占用多少内存空间，我们通常用「空间复杂度」来描述。

因此，评价一个算法的效率主要是看它的时间复杂度和空间复杂度情况。然而，有的时候时间和空间却又是「鱼和熊掌」，不可兼得的，那么我们就需要从中去取一个平衡点。

下面我来分别介绍一下「时间复杂度」和「空间复杂度」的计算方式。

## 一、时间复杂度

时间复杂度并不等于算法程序的运行时间，因为在不同的机器、不同运行状态下同一台机器、测试用例的差异、不同语言等都会有不同的结果。所以这个观点是片面的。

为了合理应用算法的时间复杂度，通用的方法就是 `T(n) = O(f(n))`

>  T(n) = O( f(n) )，其中f(n) 表示每行代码执行次数之和，而 O 表示正比例关系

常见的时间复杂度量级有：

- 常数阶O(1)
- 对数阶O(logN)
- 线性阶O(n)
- 线性对数阶O(nlogN)
- 平方阶O(n²)
- 立方阶O(n³)
- K次方阶O(n^k)
- 指数阶(2^n)

**常数阶 O(1)**

无论代码执行了多少行，只要是没有循环等复杂结构，那这个代码的时间复杂度就都是O(1)，如：

```js
var i = 1;
var j = 2;
++i;
j++;
var m = i + j;
```

**对数阶 0(n)**

```js
for(let i=1; i<=n; ++i){
   j = i;
   j++;
}
```

**对数阶O(logN)**

```js
var i = 1;
while(i<n){
  i = i * 2;
}
```

**平方阶O(n2)**

```js
for(var x=1; i<=n; x++){
   for(var i=1; i<=n; i++){
       j = i;
       j++;
    }
}
```

## 二、空间复杂度

正如时间复杂度不是由算法程序执行耗时计算一样，空间复杂度也不是用来计算程序实际占有空间。

**空间复杂度**是针对算法程序运行过程中占用存储空间大小的一个量度。

常见的空间复杂度量级有：**O(1)、O(n)、O(n²)**

**空间复杂度 O(1)**

法执行所需要的临时空间不随着某个变量n的大小而变化，即此算法空间复杂度为一个常量，可表示为 O(1)

```js
var i = 1;
```

**空间复杂度 O(n)**

虽然有循环，但没有再分配新的空间。代码的空间复杂度主要看第一行即可，即 S(n) = O(n)

```js
var m = new Array(n)
for(var i=1; i<=n.length; ++i){
   j = i;
   j++;
}
```

